#Project: Project 1 AI
#Creator: Eric Dockery
#Assignment Details: Brute Force Permutation finding minimum cost path
#Format of data:
    #NAME: concorde4
    #TYPE: TSP
    #COMMENT: Generated by CCutil_writetsplib
    #COMMENT: Write called for by Concorde GUI
    #DIMENSION: 4
    #EDGE_WEIGHT_TYPE: EUC_2D
    #NODE_COORD_SECTION
    #1 87.951292 2.658162
    #2 33.466597 66.682943
    #3 91.778314 53.807184
    #4 20.526749 47.633290
    #ect...


#import math - sqrt and operator - location of min path
import math
import operator
#imageing imports
from tkinter import *
#from PIL import Image, ImageTk
from datetime import datetime
start_time = datetime.now()

#could draw in graphics?
def plotPoints(Array, distance):
    print(Array)
    #Make a GUI
    Map = Tk()
    w = Canvas(Map, width=300, height=300)
   
    #image = Image.open("Map_Westeros_political.gif")
    #photo = ImageTk.PhotoImage(image)
    Map.title("The Travel Map")
    Map.geometry("300x280+300+300")
    #Map.image=photo

    #for loop for oval
    for i in range(len(Array)):
        #plot points
        w.create_oval(float(Array[i][1]), float(Array[i][2]),
                      (float(Array[i][1])+3),(float(Array[i][2])+3),
                      fill='green', width=4)
    for i in range(len(Array)-1):
        #drawLines
        w.create_line(float(Array[i][1]), float(Array[i][2]),
                      float(Array[i+1][1]),float(Array[i+1][2]))

    w.create_rectangle(150,150,300,250, outline="red")
    w.create_text(150,200, anchor=W, font="Purisa", text= distance)
    #finish image
    w.pack()
     
    

#distance formula
def distanceFormula(Array):
    # d = sqrt( (x2-x1)^2 +(y2-y1)^2)
    #this will be the 2ed deminsional values that are used to calculate the distance
    #Array format [[Num, X, Y], [Num ,X,Y] ...
    #i = [Num, X, Y]
    distance = 0
    #display each permutation
   # print("This Permutation Set: ")
   # print(Array)
    if (len(Array) <=1):
        distance = 0
    for i in range(0,(len(Array)-1)):
        #Array[i][1] = X ; Array[i][2] = Y
        distance += math.sqrt((float(Array[i+1][1])-float(Array[i][1]))**2 + (float(Array[i+1][2])-float(Array[i][2]))**2)
    #Display the distance for that permutation
   # print("Equals this distance: ")
   # print(distance)
    return distance

#hashmap -place, can go
#start is hard coded '1'
#end is hard coded '11'
def DepthFirstSearch(hashmap, start, end):
    #add the first element to the stack of elements
    stack = [(start, [start])]
    #while the stack isnt empty
    while stack:
        #add the next vertex to the stack returning the last object
        (vertex, path) = stack.pop()
        #for the next item from the vertex remove it from the path
        for next in hashmap[vertex] - set(path):
            #if the next element is the end 
            if next == end:
                #return the path and the next item
                yield path + [next]
            #if its not the end
            else:
                #add the next item to the path and try again
                stack.append((next, path + [next]))
         
            
def BreadthFirstSearch(hashmap, start, end):
    #add the first to the queue
    queue = [(start, [start])]
    #while there is something in the que
    while queue:
        #find the path for the queue returning the first object
        (vertex, path) = queue.pop(0)
        #for each element in the path
        for next in hashmap[vertex] - set(path):
            #if the next element is the end
            if next == end:
                #return the path and the next item
                yield path + [next]
            #else add the next item the the queue
            else:
                queue.append((next, path + [next]))


#program Main:
def main():
    #filename
    filename = "11PointDFSBFS.tsp"
    #mapping the connections
    mapping = {1:set([2, 3, 4]),2:set([3]),3:set([4,5]),
                    4:set([5,6,7]),5:set([7,8]),6:set([8]),
                    7:set([9, 10]),8:set([9, 10, 11]),9:set([11]),
                    10:set([11]),11:set([])}
    minCost = 0
    #verify map
  #  for key in mapping:
 #       print(key)
  #      print(mapping[key])

    
    #Read lines 0-6 with no cord data
  #  filename = input("What is the file name? ")
    with open(filename) as f:
  #      print("read the file")
        #read and strip the '\n'
        content = [line.rstrip('\n') for line in open(filename)]
        
    #line 7 starts the important information
    startCords = 0
    #seperate the values into a dictionary with the key being the first
    #value of the strings starting on line 7
    parsedContent = [0] * (len(content)-7)
 
    counter = 0
    #parsedContent [['object', 'X', 'Y']]
    for i in range(7,len(content)):
        parsedContent[counter] = content[i].split()
        counter+=1
    #Find the D/B First Search which will return the shortest distance
  #  search ="D"
    search = input("Enter B for BreadthFirstSearch or D for DepthFirstSearch: ")
    if(search == "B"):
        test =list(BreadthFirstSearch(mapping, 1, 11))
        ShortestPath = test[0]
    elif (search =="D"):
        test= list(DepthFirstSearch(mapping,1,11))
        ShortestPath = test
    else:
        print("You entered incorrectly automatically running BreadthFirstSearch")
        test =list(BreadthFirstSearch(mapping, 1, 11))


    #for each test array replace the value with the parsedContent of that spot
  #  print(test)
  #  print("This is parsed Content")
  #  print(parsedContent)
    minCost =111111111111111111111
    
    print("Calculating the distance")
    #for each set of paths
    for i in range(len(ShortestPath)):
        #for each element in the path
        minPath =[0] * len(test[i])
        minPath =test[i]
        for j in range(len(test[i])):
            

            #for each point
            for k in range(len(parsedContent)):
                    #if the key value is in the parsed Content
                   if (test[i][j] == int(parsedContent[k][0])):
                       #replace the key with the location for distance formula
                           test[i][j] =parsedContent[k]
        test[i] = distanceFormula(test[i])
        if (test[i] < minCost):
            minCost =test[i]
            finalPath = minPath
    
   # print(test)
    #print the integer values as well as return the list of costs
    print("The minimum cost is: ")
    print(minCost)
    print("The minimum path is:")
    finalminimumpath = [0] *len(finalPath)
    for i in range(len(finalPath)):
        finalminimumpath[i] =(int(finalPath[i][0]))
    print(finalminimumpath)
    plotPoints(finalPath, minCost)
    end_time = datetime.now()
    print('Duration: {}'.format(end_time - start_time))
main()
