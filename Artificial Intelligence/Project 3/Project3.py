#Project: Project 1 AI
#Creator: Eric Dockery
#Assignment Details: Brute Force Permutation finding minimum cost path
#Format of data:
    #NAME: concorde4
    #TYPE: TSP
    #COMMENT: Generated by CCutil_writetsplib
    #COMMENT: Write called for by Concorde GUI
    #DIMENSION: 4
    #EDGE_WEIGHT_TYPE: EUC_2D
    #NODE_COORD_SECTION
    #1 87.951292 2.658162
    #2 33.466597 66.682943
    #3 91.778314 53.807184
    #4 20.526749 47.633290
    #ect...


#import math - sqrt and operator - location of min path
import math
import operator
#imageing imports
from tkinter import *
#from PIL import Image, ImageTk
from datetime import datetime
start_time = datetime.now()

#could draw in graphics?
def plotPoints(Array, distance, filename):
    #Make a GUI
    Map = Tk()
    w = Canvas(Map, width=1000, height=500, bg ="white")
    text = Label( Map, text=filename)
    text.pack()
    #image = Image.open("Map_Westeros_political.gif")
    #photo = ImageTk.PhotoImage(image)
    Map.title("The Travel Map")
    Map.geometry("1500x880")
    #Map.image=photo

    #for loop for oval
    for i in range(len(Array)):
        #plot points
        w.create_oval((float(Array[i][1])+45)*3, (float(Array[i][2])+45)*3,
                      ((float(Array[i][1]))+57)*3,((float(Array[i][2]))+57)*3)
        #add point numbers
        w.create_text((float(Array[i][1])+48)*3,(float(Array[i][2])+50)*3, text= Array[i][0] )

    for i in range(len(Array)-1):
        #drawLines
       w.create_line((float(Array[i][1])+50)*3, (float(Array[i][2])+50)*3,
                     (float(Array[i+1][1])+50)*3,(float(Array[i+1][2])+50)*3)

    w.create_rectangle(600,300,900,400, outline="red")
    w.create_text(700,350, anchor=W, font="Purisa", text= distance)
    #finish image
    w.pack()
     
    

#distance formula
def distanceFormula(Array):
    # d = sqrt( (x2-x1)^2 +(y2-y1)^2)
    #this will be the 2ed deminsional values that are used to calculate the distance
    #Array format [[Num, X, Y], [Num ,X,Y] ...
    #i = [Num, X, Y]
    distance = 0
    #array of distance values the same length of the values
    whoIsCloser =[0] *(len(Array)**2)
    
    #display each permutation
   # print("This Permutation Set: ")
   # print(Array)
    if (len(Array) <=1):
        distance = 0
    #for each value calculate the distance value
    j = 0
    k =0
    for i in range(0,(len(Array)**2)):
        #comparing each linear object
        if (j == len(Array)):
            j = 0
            k+=1
           # print(Array[j][1])
           # print(Array[i][1])
        whoIsCloser[i] = math.sqrt((float(Array[j][1])-float(Array[k][1]))**2 + (float(Array[j][2])-float(Array[k][2]))**2)
  #      print(whoIsCloser[i])
        j+=1
        
    #Display the distance for that permutation
   # print(whoIsCloser)
   
   
    return whoIsCloser
def FindFirstNode(parsedContent, setArray):
    startOfPath = [0]* 2
    #temp closest value -- put this in FindingFirstNodeFunction
    closeness=0
    #see if this value is closer
    testcloseness =0
    #this is the node we are in
    location = 0
    #this is the node we travel to
    closestnode = 0    
    #for each sets of nodes
    for i in range (0, len(parsedContent)):
        #for each next node
        for j in range(0, len(parsedContent)):
            #if this is the first pass store 
            if (i ==0 and j == 0):
                closeness = setArray[i][j]
                closestnode=j
            else:
                if(j == 0):
                    closestnode=j
                #will get the next value
                testcloseness =setArray[i][j]
                #if the next value isn't current node
                if (testcloseness != 0):
                    if(closeness == 0 or closeness >testcloseness):
                        closeness = testcloseness
                        location = j
                        closestnode =j
                    
       #         print(closestnode)
                #print(closeness)
                

  #  print(parsedContent[location][0]) #starting point
  #  print(parsedContent[closestnode][0]) #next node
    #store the starting location and the next value in an array to return
    startOfPath[0] = parsedContent[location-1][0]
    startOfPath[1] = parsedContent[closestnode][0]
 #   print(startOfPath)
    return startOfPath


#program Main:
def main():
    #filename
 #   filename = "11PointDFSBFS.tsp"
    #mapping the connections
  
    minCost = 0
    #verify map
  #  for key in mapping:
 #       print(key)
  #      print(mapping[key])

    
    #Read lines 0-6 with no cord data
    filename = input("What is the file name? ")
    with open(filename) as f:
  #      print("read the file")
        #read and strip the '\n'
        content = [line.rstrip('\n') for line in open(filename)]
        
    #line 7 starts the important information
    startCords = 0
    #seperate the values into a dictionary with the key being the first
    #value of the strings starting on line 7
    parsedContent = [0] * (len(content)-7)
 
    counter = 0
    #parsedContent [['object', 'X', 'Y']]
    for i in range(7,len(content)):
        parsedContent[counter] = content[i].split()
        counter+=1

    #distanceFormula calculates all of the distances in one array and returns it
    theDistanceArray = distanceFormula(parsedContent)
  #  print(theDistanceArray)
    #short set to evaluate each nodes closest node
    setArray= [0]* len(parsedContent)
    shortShot = [0] * len(parsedContent)
    k =0
    #calculate the shortset traversal
    for i in range (0, len(theDistanceArray), len(parsedContent)): #skipping by the length of the sets
        for j in range (0, len(parsedContent)): #this will go through the length
             #of the parsedContent and form a set
             shortShot[j] = theDistanceArray[i+j]
        #setArray will have a array of distances
        setArray[k] =shortShot
        k+=1
        shortShot =[0]* len(parsedContent)
#    print(setArray)
    #get the first two values of the set
 #   print(setArray)
    StartArray = [0]*2
    StartArray = FindFirstNode(parsedContent, setArray) 
    #print(StartArray)
    #get the two values
    k = int(StartArray[0])
    j = int(StartArray[1])
    #add to the distance for these two
    tempcost= setArray[k-1]
  #  print(tempcost)
    minCost = float(setArray[k-1][j-1])
 #   print(k)
#    print(setArray[0][k-1])
    #remove these two paths from the possible locations
    for i in range (0, len(parsedContent)):
        setArray[i][k-1] =0
        setArray[i][j-1]= 0
 #   print(setArray)
    #start the final path
    finalPath = [0]*(len(parsedContent)+1)
    finalPath[0] = k
    finalPath[len(parsedContent)] =k
    finalPath[1] = j

    #for every node after the first two
    closeness=0
    #see if this value is closer
    testcloseness =0
    #this is the node we are in
    location = 0
    #this is the node we travel to
    closestnode = 0    
    #for each sets of nodes
    for i in range (1, len(parsedContent)-1):
        #for each next node
        for l in range(0, len(parsedContent)):
            #if this is the first pass store 
            if (l ==0):
                closeness = setArray[j-1][l]
                closestnode =l
            #will get the next value
            testcloseness =setArray[j-1][l]
   #         print("test")
    
    #        print(testcloseness)
     #       print(closeness)
            #if the next value isn't current node
            if (testcloseness != 0):
                if(closeness == 0 or closeness >testcloseness):
                    closeness = testcloseness
                    closestnode = l
      #              print(closestnode)
               # else: #if closesness is not zero or greater than testcloseness
                    #closestnode=l
      #  print(setArray[i])
      #  print(closestnode+1)
            
                    
     #   print(closestnode)

        #add cost
        minCost+= float(setArray[j-1][closestnode])
    #    print(minCost)
        #next pathpoint
        finalPath[i+1] = closestnode+1
        j= closestnode+1
        #if we are on the last value
        if (i == len(parsedContent)-2):
    #        print("I am here")
            
            minCost+=float(tempcost[closestnode])
        #remove the options for the next node
        for node in range(0, len(parsedContent)):
            setArray[node][closestnode]= 0
       # print(setArray)
            
   # print(finalPath)
        

    #print the integer values as well as return the list of costs
    print("The minimum cost is: ")
    print(minCost)
    print("The minimum path is:")
    print(finalPath)
    #set the finalpath values to the x, y values
    for i in range(0, len(finalPath)):
        for j in range(0, len(parsedContent)):
            if (finalPath[i] == int(parsedContent[j][0])):
                finalPath[i] = parsedContent[j]
    plotPoints(finalPath, minCost, filename)
    
main()
